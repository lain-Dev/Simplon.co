Comme nous l'avons vu plus t√¥t, Webpack est un bundler, il va vous permettre de compiler votre code et de tout packager en un seul fichier, mais √ßa ne s'arr√™te pas l√† !

Webpack peut aussi g√©rer vos ressources (images, styles css, etc.) avec ce qu'on appelle des loaders, et il va vous permettre de g√©rer diff√©rentes phases que nous avons vues lors de l'optimisation : bundler, minifier et transpiler.

Pr√©paration du terrain
Une fois que vous avez ex√©cut√©  npm init  dans votre r√©pertoire pour initialiser votre projet avec NPM, nous pouvons mettre en place les outils.

Installation de Webpack
Pour installer Webpack, il suffit d'ex√©cuter cette commande :

npm install webpack webpack-cli --save-dev
Projet de base
Pour ce chapitre, nous allons partir sur une base de code tr√®s simple. Voici les fichiers dont nous allons avoir besoin :

project
|- package.json
|- index.html
|- src
    |- index.js
    |- query.js
Voici le contenu des diff√©rents fichiers :

package.json

{
  "name": "my-project",
  "version": "1.0.0",
  "description": "",
  "private": true,
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "webpack": "^4.21.0",
    "webpack-cli": "^3.1.2"
  },
  "dependencies": {
  }
}

index.html

<!doctype html>
<html>
<head>
    <title>My project</title>
</head>
<body>
    <script src="./dist/app.bundle.js"></script>
</body>
</html>
src/index.js

import retrieveContent from './query.js';

async function showContent() {
  try {
    const content = await retrieveContent();

    let elt = document.createElement('div');
    elt.innerHTML = content.join('<br />');

    document.getElementsByTagName('body')[0].appendChild(elt);
  } catch (e) {
    console.log('Error', e);
  }
}

showContent();
src/query.js


export default async function retrieveContent() {
  const url = "https://baconipsum.com/api/?type=all-meat&paras=2&start-with-lorem=1";

  const response = await fetch(url);
  return response.json();
}

Vous noterez que dans le fichier query.js , nous utilisons une fonction  fetch . Il s'agit d'une fonction permettant de faire des requ√™tes HTTP sans avoir √† utiliser directement AJAX, qui est un peu plus lourd.

Compilation du projet avec Webpack
Maintenant que nous avons une base de code, voyons comment compiler notre projet.

Nous allons cr√©er un fichier  webpack.config.js  √† la racine du projet. C'est le fichier qui servira de configuration √† Webpack pour savoir comment il doit compiler notre projet.

webpack.config.js

const path = require('path');

module.exports = {
  mode: "production",
  entry: {
    app: "./src/index.js"
  },
  output: {
    filename: "[name].bundle.js",
    path: path.resolve(__dirname, "dist")
  }
};
Ce fichier nous indique principalement que Webpack va se servir de notre  ./src/index.js  comme point d'entr√©e de notre application et bundler notre code dans un fichier final :  ./dist/app.bundle.js ( [name]  √©tant une variable qui sera remplac√©e ici par  app , car c'est le nom que l'on a indiqu√© pour notre fichier  index.js ).

Avec notre fichier de configuration pr√™t, il ne nous reste plus qu'√† ex√©cuter Webpack. Pour cela, nous allons utiliser une des fonctionnalit√©s de NPM : les commandes.

Nous allons modifier le fichier  package.json  pour ajouter dans les  "scripts": {....}  la ligne suivante : 

"scripts": {
    "test": "...",
    "build": "webpack"
}
Tout ce qui se trouve dans  scripts  peut √™tre ex√©cut√© avec la commande  npm run <script_name> . Ainsi, nous pouvons ex√©cuter  npm run build  qui va ex√©cuter la commande  webpack .

Pourquoi ne pas ex√©cuter directement la commande  webpack , me direz-vous ? Eh bien, parce qu'en r√©alit√© cette application se trouve dans le dossier  ./node_modules/.bin/webpack . Or, l'avantage de NPM est qu'il va automatiquement chercher dans ce dossier pour ex√©cuter des commandes, ainsi on s'√©pargne le chemin entier (oui, le d√©veloppeur est bien un fain√©ant üòä).

Nous pouvons donc compiler un projet avec :

npm run build
Si tout se passe bien, un fichier  app.bundle.js  devrait √™tre g√©n√©r√© dans le dossier  dist/ . Notre projet a bien √©t√© packag√© en un seul fichier, alors que nous en avions 2 √† l'origine (index.js  et  query.js ). Alors, par quelle magie est-ce que Webpack a su o√π aller chercher tous nos fichiers √† partir de notre fichier  index.js  ?

Gr√¢ce aux  import  et  export . Ces 2 mots cl√©s permettent respectivement d'importer un autre fichier (qui est appel√© un module) et d'exporter des choses (fonctions, variables...).

Nous pouvons, en effet, voir que dans notre fichier  index.js , nous avons import√© le module  query.js  sous le nom  retrieveContent. Et dans notre fichier  query.js , nous pouvons voir que nous avons export√© la fonction  retrieveContent  (ce qui la rend disponible √† l'import). Ainsi, quand Webpack analyse votre code, il retrouve toutes ces d√©pendances et se cr√©e un graph en interne afin d'√™tre capable de tout remettre dans l'ordre dans un seul fichier.

Mais ce n'est pas encore suffisant. En effet, nous utilisons  async  et  await  qui sont apparus dans une version r√©cente de JavaScript que tous les navigateurs ne supportent pas encore. Ainsi, en fonction du navigateur, le code affichera une erreur. De quoi avons-nous besoin alors ? D'un transpiler afin de rendre notre code JavaScript compatible avec les navigateurs les moins r√©cents !

Transpiler avec Babel
Afin d'utiliser Babel, nous allons devoir l'installer. Mais nous aurons aussi besoin d'installer le loader Babel qui permet de l'int√©grer √† Webpack. Il est en effet possible d'√©tendre les capacit√©s de Webpack avec des plugins et des loaders.

npm install --save-dev babel-loader @babel/core @babel/preset-env babel-polyfill
Il va falloir ajouter Babel √† la configuration de Webpack. Pour cela, il faut y ajouter ce qu'on appelle des  rules . Les  rules  sont des r√®gles de Webpack indiquant les loaders √† utiliser pour les types de fichiers que l'on souhaite. Cela veut dire que d√®s que l'on va importer un module dans notre code, Webpack va regarder dans la liste des  rules  s'il y en a une qui correspond √† ce type de fichier, et il va lui appliquer les loaders qui correspondent.

Dans notre cas, nous voulons ex√©cuter Babel pour tous les fichiers JavaScript de notre projet (sauf ceux qui se trouvent dans le dossier  node_modules , car ce sont les d√©pendances NPM et nous ne sommes pas cens√©s modifier leur code).

webpack.config.js

const path = require('path');

module.exports = {
  mode: "production",
  entry: {
    polyfill: "babel-polyfill",
    app: "./src/index.js"
  },
  output: {
    filename: "[name].bundle.js",
    path: path.resolve(__dirname, "dist")
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: {
          loader: "babel-loader",
          options: {
            presets: ["@babel/preset-env"]
          }
        }
      }
    ]
  }
};
Vous pouvez passer des options aux loaders. Ainsi, pour Babel, vous pourriez lui demander de charger d'autres plugins pour g√©rer des syntaxes qui ne sont encore que des propositions pour de futures versions de JavaScript. Ici, nous chargeons le preset de base qui va nous permettre de transpiler notre code.

Vous remarquerez aussi que nous avons ajout√© une entr√©e dans l'objet  entry  :  polyfill: "babel-polyfill" . Cela veut dire que lorsque nous compilons notre code, deux fichiers vont √™tre g√©n√©r√©s : notre code depuis notre fichier  index.js  et le polyfill de Babel. Le polyfill permet √† Babel d'apporter des modifications au code lors de son ex√©cution. Cela peut √™tre n√©cessaire pour certaines choses, et c'est le cas de  async  /  await . Afin de prendre en compte ce fichier de polyfill, il va falloir mettre √† jour le fichier  index.html  afin de le charger aussi (avant notre code) :

index.html

<!doctype html>
<html>
    <head>
        <title>My project</title>
    </head>
    <body>
        <script src="./dist/polyfill.bundle.js"></script>
        <script src="./dist/app.bundle.js"></script>
    </body>
</html>
Avec √ßa, tous les navigateurs devraient afficher la page et ex√©cuter correctement le code g√©n√©r√© par  npm run build .

Si un jour vous avez la curiosit√© de regarder √† quoi ressemble un code g√©n√©r√© par Webpack, vous verrez que ce n'est pas tr√®s lisible.

Eh bien c'est √† cause de la minification du code ! Webpack, dans sa version actuelle, compresse le code automatiquement lorsque vous le param√©trez avec  mode: 'production' , ce qui est le cas ici !

Webpack-dev-server
Nous avons maintenant un environnement optimis√© qui vous permet :

De minifier votre code ;

De packager votre code ;

De s√©parer tr√®s facilement votre code en plusieurs fichiers afin de bien l'organiser ;

D'utiliser tr√®s facilement des biblioth√®ques d√©velopp√©es par la communaut√© gr√¢ce √† NPM ;

De transpiler votre code pour pouvoir utiliser les versions next gen de JavaScript ;

...

Que demander de plus ?

Un serveur pour tester votre code et qui recharge automatiquement votre navigateur d√®s que vous modifiez votre code ?

Alors allons-y ! C'est exactement ce que webpack-dev-server permet de faire :soleil:.

Il faut tout d'abord installer le module :

npm install webpack-dev-server --save-dev
Ensuite, je vous conseille d'ajouter une nouvelle commande au fichier  package.json  :

"scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "webpack",
    "start": "webpack-dev-server"
}
start  est une commande un peu sp√©ciale car elle est ex√©cut√©e avec un simple  npm start  (vous noterez l'absence de  run  apr√®s  npm ).

Enfin, webpack-dev-server va consid√©rer que les fichiers g√©n√©r√©s par Webpack sont √† la racine du server, il nous faut donc mettre √† jour notre fichier  index.html  :

index.html

<!doctype html>
<html>
    <head>
        <title>My project</title>
    </head>
    <body>
        <script src="/polyfill.bundle.js"></script>
        <script src="/app.bundle.js"></script>
    </body>
</html>
Une fois que tout √ßa est fait, il suffit de lancer le serveur de d√©veloppement :

npm start
La commande indique que l'application est disponible √† l'adresse http://localhost:8080/. Il suffira de vous y rendre pour voir votre application.

Tant que cette commande est active, toute modification du code source activera Webpack qui recompilera le code automatiquement et rafra√Æchira le navigateur, montrant ainsi vos modifications :).

En r√©sum√©
Dans ce chapitre, vous avez appris :

√Ä installer Webpack ;

√Ä configurer Webpack pour votre projet ;

√Ä compiler votre projet ;

√Ä installer Babel pour transpiler votre code ;

√Ä utiliser  webpack-dev-server  pour tester votre application et mettre √† jour votre navigateur √† chaque modification de votre code.